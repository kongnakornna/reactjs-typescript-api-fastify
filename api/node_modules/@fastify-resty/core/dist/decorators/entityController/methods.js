"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const http_errors_1 = tslib_1.__importDefault(require("http-errors"));
const helpers_1 = require("../../helpers");
const getPaginationConfig = (config) => typeof config.pagination === 'boolean' ? null : config.pagination;
exports.default = {
    find(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const query = request.query;
            if (!this.config.pagination) {
                return { data: this.model.find(query) };
            }
            const paginationConfig = getPaginationConfig(this.config);
            if (paginationConfig && query.$limit === undefined) {
                query.$limit = paginationConfig.limit;
            }
            return {
                data: yield this.model.find(query),
                skip: query.$skip || 0,
                limit: query.$limit || paginationConfig.limit,
                total: paginationConfig.total && (yield this.model.total(query))
            };
        });
    },
    findOne(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const results = yield this.model.find({ $where: { [this.config.id]: request.params.id } });
            if (results.length === 0) {
                throw http_errors_1.default(404, `${this.model.name} #${request.params.id} is not found`);
            }
            return results[0];
        });
    },
    create(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { identifiers } = yield this.model.create(request.body);
            if (helpers_1.get(request.query.$results, this.config.returning)) {
                return yield this.model.find({ $where: { [this.config.id]: { $in: identifiers } } });
            }
            return identifiers;
        });
    },
    patch(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = {};
            let patchIds;
            if (helpers_1.get(request.query.$results, this.config.returning)) {
                const patchQuery = yield this.model.find({ $select: [this.config.id], $where: request.query });
                patchIds = patchQuery.map(row => row[this.config.id]);
            }
            const { affected } = yield this.model.patch(request.query, request.body);
            response.affected = affected;
            if (helpers_1.get(request.query.$results, this.config.returning)) {
                response.data = yield this.model.find({ $where: { [this.config.id]: { $in: patchIds } } });
            }
            return response;
        });
    },
    patchOne(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { params: { id }, query: { $results } } = request;
            const { affected } = yield this.model.patch({ [this.config.id]: id }, request.body);
            if (helpers_1.get($results, this.config.returning)) {
                return (yield this.model.find({ $where: { [this.config.id]: id } }))[0];
            }
            return { affected };
        });
    },
    update(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = {};
            let updateIds;
            if (helpers_1.get(request.query.$results, this.config.returning)) {
                const updateQuery = yield this.model.find({ $select: [this.config.id], $where: request.query });
                updateIds = updateQuery.map(row => row[this.config.id]);
                if (!updateIds.length) {
                    return { affected: 0, data: [] };
                }
            }
            const { affected } = yield this.model.update(request.query, request.body);
            response.affected = affected;
            if (helpers_1.get(request.query.$results, this.config.returning)) {
                response.data = yield this.model.find({ $where: { [this.config.id]: { $in: updateIds } } });
            }
            return response;
        });
    },
    updateOne(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { params: { id }, query: { $results } } = request;
            const { affected } = yield this.model.update({ [this.config.id]: id }, request.body);
            if (helpers_1.get($results, this.config.returning)) {
                const result = yield this.model.find({ $where: { [this.config.id]: id } });
                return result[0];
            }
            return { affected };
        });
    },
    remove(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = {};
            if (helpers_1.get(request.query.$results, this.config.returning)) {
                response.data = yield this.model.find({ $where: request.query });
                if (!response.data.length) {
                    return { affected: 0, data: [] };
                }
            }
            const { affected } = yield this.model.remove(request.query);
            response.affected = affected;
            return response;
        });
    },
    removeOne(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { params: { id }, query: { $results } } = request;
            let removedRow;
            if (helpers_1.get($results, this.config.returning)) {
                const results = yield this.model.find({ $where: { [this.config.id]: id } });
                if (results.length === 0) {
                    throw http_errors_1.default(404, `${this.model.name} #${request.params.id} is not found to be removed`);
                }
                removedRow = results[0];
            }
            const { affected } = yield this.model.remove({ [this.config.id]: id });
            if (helpers_1.get($results, this.config.returning)) {
                return removedRow;
            }
            return { affected };
        });
    }
};
